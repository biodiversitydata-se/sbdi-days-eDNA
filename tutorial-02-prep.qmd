---
title: "2. Prepare data"
format:
  html:
    toc: false
---

*Load, merge and aggregate ASV portal data into a format suitable for downstream ecological analyses.*

### Load the datasets

Load the two 16S datasets using the `data_path` object defined in the [previous section](tutorial-01-setup.qmd):

```r
loaded <- load_data(data_path)
```

This reads all datasets into the `loaded` object, which you can inspect using the magnifying glass in the Environment pane. The object is list organised into sub-lists by data type, each containing one table or matrix element per dataset:

- `counts`: ASV read counts
- `asvs`: ASV sequences and taxonomic annotations
- `events`: core sample-level metadata (*where, when, how, who*)
- `datasets`: dataset-level metadata
- `emof`: dataset-specific *extended measurement or fact* contextual data

When inspecting the lower-level objects, you can see dataset sizes (e.g. `KTH-2013-Baltic-16S`: 3,074 ASVs × 21 samples). Sparse matrices (`dgCMatrix`) are used to reduce memory usage for count data, while tabular structures (`data.table`) are used for metadata.

To see the full function documentation for `load_data`:

```r
?asvoccur::load_data
```


---

### Merge the datasets

Next, we merge the datasets in order to analyse them jointly:

```r
merged <- merge_data(loaded)
```

The `merged` object has the same overall structure as `loaded`, but now contains a single combined version of each table (`counts`, `events`, `asvs`, `emof`).

To reduce memory usage, ASV count tables in both `loaded$counts` and `merged$counts` are stored as sparse matrices.

---

### Convert merged data to data frames (optional)

For some analyses, it is convenient to work with regular data frames instead of sparse matrices. We can convert the merged object as follows:

```r
merged_df <- convert_to_df(merged, convert_counts = TRUE, max_cells = 1e9)
```

In `merged_df$counts`, each row corresponds to an ASV and each column to a sample. To inspect the sample names:

```r
colnames(merged_df$counts)
```

When converting, ASVs shared across datasets are merged using SBDI ASV IDs. These IDs correspond to MD5 hashes of the sequences, meaning that ASVs with identical sequences are represented only once.

---

### Aggregate counts by taxonomy

We now aggregate ASV read counts at different taxonomic levels based on the taxonomic annotation:

```r
cladecounts <- sum_by_clade(merged$counts, merged$asvs)
```

This produces aggregated counts at the following levels:

- kingdom (or domain)
- phylum
- class
- order
- family
- genus
- species
- otu (if available)

We convert the result to data frame format:

```r
cladecounts_df <- convert_to_df(cladecounts)
```

Both raw counts and normalised counts (relative abundances) are available. For example:

```r
cladecounts_df$raw$phylum     # raw counts at phylum level
cladecounts_df$norm$species  # relative abundances at species level
```

At this point, the data are ready for exploration and analysis.

---

[← Previous](tutorial-01-setup.qmd) · [Overview](tutorial.qmd) · [Next →](tutorial-03-map.qmd)
